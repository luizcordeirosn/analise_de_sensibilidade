# -*- coding: utf-8 -*-
"""CNN Keras - Análise de Sensibilidade.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u8kAsHj7GTdQYBSB4lkj9zvGKNW4BMPE

**Grupo:** Felipe Maciel, Cheldon Andrade, Luiz Neto e Vitor Barbosa

**Problema proposto:**

Base de Dados - MNIST<br>
Treinamento - 60.000 exemplos<br>
Teste - 10.000 exemplos<br><br>
Definir uma simples rede Convolucional com o Keras

Realizar uma análise de sensibilidade variando os seguintes parâmetros e
hiperparâmetros:

1) Número de camadas convolucionais e filtros ( pelo menos 4 variações)<br>
2) Dropout - 4 valores<br>
3) Testar diferentes algoritmos de otimização - SGD, RMSprop e Adam (pelo menos 3)<br>
4) Variar o número de épocas (mínimo de 3)<br>
5) Variar a taxa de aprendizagem ( mínimo de 3)<br>
6) Incrementar o tamanho do batch ( mínimo de 3)

# Fazendo os Imports necessários e carregando o dataset
"""

import tensorflow as tf
from tensorflow.keras import layers,models
from tensorflow import keras
import numpy as np
import matplotlib.pyplot as plt

(X_train, y_train) , (X_test, y_test) = keras.datasets.mnist.load_data()

# Normalizar os dados de forma que fiquem com valores entre 0 e 1

X_train = X_train / 255
X_test = X_test / 255

# Redimensionando a matriz

X_train = X_train.reshape(-1,28,28,1)
X_train.shape

X_test = X_test.reshape(-1,28,28,1)
X_test.shape

"""# Para o algoritmo de otimização SGD

**Simulação 1** - 1 camadas de entrada, 2 camadas convolucionais, 1 camada densa oculta e 1 camada de saída, 25 filtros na camada convolucional de entrada, 64 filtros nas duas camadas convolucionais, 
Dropout: 0.2,
Número de épocas: 10,
Taxa de aprendizagem: 0.01,
Tamanho do batch: 32 (padrão)
"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=25, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.2),

    layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.2),
    
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.SGD(learning_rate=0.01)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,10), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,10), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,10), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,10), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 2** - 1 camadas de entrada, 1 camadas convolucional, 1 camada densa oculta e 1 camada de saída, 32 filtros na camada convolucional de entrada, 32 filtros na camada convolucional, Dropout: 0.3, Número de épocas: 12, Taxa de aprendizagem: 0.015, Tamanho do batch: 64

"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=25, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.3),
    
    layers.Flatten(),
    layers.Dense(32, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.SGD(learning_rate=0.015)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=12, batch_size=64, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,12), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,12), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,12), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,12), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 3** - 1 camadas de entrada, 2 camadas convolucionais, 1 camada densa oculta e 1 camada de saída, 30 filtros na camada convolucional de entrada, 50 filtros nas duas camadas convolucionais, 
Dropout: 0.25,
Número de épocas: 14,
Taxa de aprendizagem: 0.02,
Tamanho do batch: 75

"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=30, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=50, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),

    layers.Conv2D(filters=50, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),
    
    layers.Flatten(),
    layers.Dense(32, activation='relu'),
    layers.Dense(20, activation='softmax'),
])

opt = keras.optimizers.SGD(learning_rate=0.02)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=14, batch_size=75, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,14), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,14), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,14), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,14), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 4** - 1 camadas de entrada, 1 camadas convolucional, 1 camada densa oculta e 1 camada de saída, 32 filtros na camada convolucional de entrada, 30 filtros na camada convolucional, Dropout: 0.275, Número de épocas: 18, Taxa de aprendizagem: 0.0175, Tamanho do batch: 200"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=30, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.275),
    
    layers.Flatten(),
    layers.Dense(30, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.SGD(learning_rate=0.0175)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=18, batch_size=200, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,18), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,18), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,18), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,18), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""# Para o algoritmo de otimização RMSprop

**Simulação 1** - 1 camadas de entrada, 2 camadas convolucionais, 1 camada densa oculta e 1 camada de saída, 25 filtros na camada convolucional de entrada, 64 filtros nas duas camadas convolucionais, 
Dropout: 0.2,
Número de épocas: 10,
Taxa de aprendizagem: 0.01,
Tamanho do batch: 32 (padrão)
"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=25, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.2),

    layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.2),
    
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.RMSprop(learning_rate=0.01)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,10), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,10), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,10), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,10), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 2** - 1 camadas de entrada, 1 camadas convolucional, 1 camada densa oculta e 1 camada de saída, 32 filtros na camada convolucional de entrada, 32 filtros na camada convolucional, Dropout: 0.3, Número de épocas: 12, Taxa de aprendizagem: 0.015, Tamanho do batch: 64

"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=25, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.3),
    
    layers.Flatten(),
    layers.Dense(32, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.RMSprop(learning_rate=0.015)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=12, batch_size=64, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,12), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,12), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,12), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,12), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 3** - 1 camadas de entrada, 2 camadas convolucionais, 1 camada densa oculta e 1 camada de saída, 30 filtros na camada convolucional de entrada, 50 filtros nas duas camadas convolucionais, 
Dropout: 0.25,
Número de épocas: 14,
Taxa de aprendizagem: 0.02,
Tamanho do batch: 75

"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=30, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=50, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),

    layers.Conv2D(filters=50, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),
    
    layers.Flatten(),
    layers.Dense(32, activation='relu'),
    layers.Dense(20, activation='softmax'),
])

opt = keras.optimizers.RMSprop(learning_rate=0.02)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=14, batch_size=75, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,14), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,14), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,14), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,14), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 4** - 1 camadas de entrada, 1 camadas convolucional, 1 camada densa oculta e 1 camada de saída, 32 filtros na camada convolucional de entrada, 30 filtros na camada convolucional, Dropout: 0.275, Número de épocas: 18, Taxa de aprendizagem: 0.0175, Tamanho do batch: 200"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=30, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.275),
    
    layers.Flatten(),
    layers.Dense(30, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.RMSprop(learning_rate=0.0175)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=18, batch_size=200, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,18), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,18), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,18), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,18), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""# Para o algoritmo de otimização ADAM

**Simulação 1** - 1 camadas de entrada, 2 camadas convolucionais, 1 camada densa oculta e 1 camada de saída, 25 filtros na camada convolucional de entrada, 64 filtros nas duas camadas convolucionais, 
Dropout: 0.2,
Número de épocas: 10,
Taxa de aprendizagem: 0.01,
Tamanho do batch: 32 (padrão)
"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=25, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.2),

    layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.2),
    
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.Adam(learning_rate=0.01)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,10), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,10), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,10), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,10), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 2** - 1 camadas de entrada, 1 camadas convolucional, 1 camada densa oculta e 1 camada de saída, 32 filtros na camada convolucional de entrada, 32 filtros na camada convolucional, Dropout: 0.3, Número de épocas: 12, Taxa de aprendizagem: 0.015, Tamanho do batch: 64


"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=25, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.3),
    
    layers.Flatten(),
    layers.Dense(32, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.Adam(learning_rate=0.015)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=12, batch_size=64, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,12), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,12), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,12), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,12), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 3** - 1 camadas de entrada, 2 camadas convolucionais, 1 camada densa oculta e 1 camada de saída, 30 filtros na camada convolucional de entrada, 50 filtros nas duas camadas convolucionais, 
Dropout: 0.25,
Número de épocas: 14,
Taxa de aprendizagem: 0.02,
Tamanho do batch: 75

"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=30, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=50, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),

    layers.Conv2D(filters=50, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),
    
    layers.Flatten(),
    layers.Dense(32, activation='relu'),
    layers.Dense(20, activation='softmax'),
])

opt = keras.optimizers.Adam(learning_rate=0.02)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=14, batch_size=75, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,14), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,14), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,14), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,14), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()

"""**Simulação 4** - 1 camadas de entrada, 1 camadas convolucional, 1 camada densa oculta e 1 camada de saída, 32 filtros na camada convolucional de entrada, 30 filtros na camada convolucional, Dropout: 0.275, Número de épocas: 18, Taxa de aprendizagem: 0.0175, Tamanho do batch: 200"""

convolutional_neural_network = models.Sequential([
    layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2, 2)),
    
    layers.Conv2D(filters=30, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.275),
    
    layers.Flatten(),
    layers.Dense(30, activation='relu'),
    layers.Dense(10, activation='softmax'),
])

opt = keras.optimizers.Adam(learning_rate=0.0175)

convolutional_neural_network.compile(optimizer=opt, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
H = convolutional_neural_network.fit(X_train, y_train, epochs=18, batch_size=200, validation_data=(X_test, y_test))

plt.style.use("ggplot")
plt.figure()
plt.plot(np.arange(0,18), H.history["loss"], label="train_loss")
plt.plot(np.arange(0,18), H.history["val_loss"], label="val_loss")
plt.plot(np.arange(0,18), H.history["accuracy"], label="train_acc")
plt.plot(np.arange(0,18), H.history["val_accuracy"], label="val_acc")
plt.title("Training Loss and Accuracy")
plt.xlabel("Epoch #")
plt.ylabel("Loss/Accuracy")
plt.legend()
plt.show()